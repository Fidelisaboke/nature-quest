from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator, MaxValueValidator
import json


class Quiz(models.Model):
    """Quiz generated for techie users after challenge completion"""
    DIFFICULTY_CHOICES = [
        ('easy', 'Easy'),
        ('medium', 'Medium'),
        ('hard', 'Hard'),
    ]
    
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='quizzes')
    challenge_id = models.IntegerField()  # Reference to completed challenge
    difficulty = models.CharField(max_length=10, choices=DIFFICULTY_CHOICES)
    tech_stack = models.CharField(max_length=100)  # Tech stack for this quiz
    total_questions = models.IntegerField(default=5)
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    score = models.FloatField(null=True, blank=True, validators=[MinValueValidator(0), MaxValueValidator(100)])
    passed = models.BooleanField(default=False)  # True if score >= 80%
    
    class Meta:
        unique_together = ('user', 'challenge_id')  # One quiz per challenge per user
        ordering = ['-created_at']
    
    def __str__(self):
        return f"Quiz for {self.user.username} - {self.tech_stack} ({self.difficulty})"
    
    @property
    def pass_threshold(self):
        return 80.0
    
    @property
    def is_completed(self):
        return self.completed_at is not None


class Question(models.Model):
    """Individual questions within a quiz"""
    QUESTION_TYPES = [
        ('multiple_choice', 'Multiple Choice'),
        ('checkbox', 'Checkbox'),
    ]
    
    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE, related_name='questions')
    question_type = models.CharField(max_length=20, choices=QUESTION_TYPES)
    question_text = models.TextField()
    tech_stack = models.CharField(max_length=100)
    difficulty = models.CharField(max_length=10, choices=Quiz.DIFFICULTY_CHOICES)
    options = models.JSONField(default=list)  # List of answer options
    correct_answers = models.JSONField(default=list)  # List of correct option indices
    explanation = models.TextField(blank=True)
    points = models.IntegerField(default=20)  # Points for correct answer
    order = models.IntegerField(default=0)  # Order within quiz
    
    # For reuse and shuffling
    reuse_count = models.IntegerField(default=0)  # Track how many times used
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['order']
    
    def __str__(self):
        return f"Q{self.order}: {self.question_text[:50]}..."
    
    @property
    def is_multiple_choice(self):
        return self.question_type == 'multiple_choice'
    
    @property
    def is_checkbox(self):
        return self.question_type == 'checkbox'


class QuizAttempt(models.Model):
    """User's answers to quiz questions"""
    quiz = models.OneToOneField(Quiz, on_delete=models.CASCADE, related_name='attempt')
    started_at = models.DateTimeField(auto_now_add=True)
    submitted_at = models.DateTimeField(null=True, blank=True)
    total_score = models.FloatField(default=0.0)
    
    def __str__(self):
        return f"Attempt: {self.quiz}"
    
    @property
    def is_submitted(self):
        return self.submitted_at is not None


class QuestionResponse(models.Model):
    """User's response to a specific question"""
    attempt = models.ForeignKey(QuizAttempt, on_delete=models.CASCADE, related_name='responses')
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    selected_answers = models.JSONField(default=list)  # List of selected option indices
    is_correct = models.BooleanField(default=False)
    points_earned = models.FloatField(default=0.0)
    answered_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ('attempt', 'question')
    
    def __str__(self):
        return f"Response to Q{self.question.order} - {self.is_correct}"


class QuestionBank(models.Model):
    """Bank of reusable questions for different tech stacks and difficulties"""
    tech_stack = models.CharField(max_length=100)
    difficulty = models.CharField(max_length=10, choices=Quiz.DIFFICULTY_CHOICES)
    question_type = models.CharField(max_length=20, choices=Question.QUESTION_TYPES)
    question_text = models.TextField()
    options = models.JSONField(default=list)
    correct_answers = models.JSONField(default=list)
    explanation = models.TextField(blank=True)
    
    # Metadata for generation
    generated_by_hf = models.BooleanField(default=False)  # Generated by Hugging Face
    source_prompt = models.TextField(blank=True)  # Original prompt used
    times_used = models.IntegerField(default=0)
    quality_score = models.FloatField(default=0.0)  # User feedback score
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)
    
    class Meta:
        ordering = ['tech_stack', 'difficulty', '-quality_score']
    
    def __str__(self):
        return f"{self.tech_stack} ({self.difficulty}): {self.question_text[:50]}..."
    
    def increment_usage(self):
        """Increment usage counter"""
        self.times_used += 1
        self.save(update_fields=['times_used'])


class QuizMetrics(models.Model):
    """Analytics and metrics for quiz performance"""
    tech_stack = models.CharField(max_length=100)
    difficulty = models.CharField(max_length=10, choices=Quiz.DIFFICULTY_CHOICES)
    total_quizzes = models.IntegerField(default=0)
    total_passes = models.IntegerField(default=0)
    average_score = models.FloatField(default=0.0)
    average_completion_time = models.FloatField(default=0.0)  # Minutes
    
    last_updated = models.DateTimeField(auto_now=True)
    
    class Meta:
        unique_together = ('tech_stack', 'difficulty')
    
    def __str__(self):
        return f"Metrics: {self.tech_stack} ({self.difficulty}) - {self.pass_rate:.1f}% pass rate"
    
    @property
    def pass_rate(self):
        if self.total_quizzes > 0:
            return (self.total_passes / self.total_quizzes) * 100
        return 0.0
